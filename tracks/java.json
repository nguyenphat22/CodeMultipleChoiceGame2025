{
  "id": "java",
  "title": "Java",
  "description": "Nền tảng Java: String, Collections, Streams, Exception, Concurrency.",
  "challenges": [
    {
      "type": "mcq",
      "title": "Khi thực hiện đoạn code dưới đây, điều gì xảy ra?",
      "code": "String s = \"a\"; s += \"b\";",
      "options": ["Tạo String mới", "Thay đổi tại chỗ", "Chuyển thành char[]", "Không đổi"],
      "answer": 0,
      "explanation": "String trong Java là immutable (bất biến). Khi nối chuỗi, Java tạo một đối tượng String mới thay vì thay đổi đối tượng cũ."
    },
    {
      "type": "mcq",
      "title": "Kết quả của equals và == trong trường hợp sau là gì?",
      "code": "Integer a = 128, b = 128;",
      "options": ["a.equals(b) true, a==b false", "Cả hai true", "Cả hai false", "a.equals(b) false, a==b true"],
      "answer": 0,
      "explanation": "Integer trong Java cache giá trị từ -128 đến 127. Vì 128 nằm ngoài phạm vi cache, a và b là hai đối tượng khác nhau (== false) nhưng equals() vẫn true."
    },
    {
      "type": "mcq",
      "title": "Danh sách nào truy cập phần tử ngẫu nhiên nhanh hơn?",
      "code": "Phép truy cập ngẫu nhiên nhanh ở?",
      "options": ["ArrayList", "LinkedList", "Cả 2 như nhau", "Không cái nào"],
      "answer": 0,
      "explanation": "ArrayList lưu trữ phần tử trong mảng liên tục, nên truy cập bằng chỉ số rất nhanh (O(1)). LinkedList cần duyệt từng nút (O(n))."
    },
    {
      "type": "mcq",
      "title": "HashMap cho phép bao nhiêu key null?",
      "code": "Số lượng key null?",
      "options": ["1", "0", "Nhiều", "Tuỳ phiên bản"],
      "answer": 0,
      "explanation": "HashMap cho phép đúng một key null, vì chỉ có thể tồn tại một mục ánh xạ cho null key."
    },
    {
      "type": "mcq",
      "title": "Đoạn stream dưới đây đã thực thi chưa?",
      "code": "list.stream().map(x -> x * 2)",
      "options": ["Chưa thực thi", "Đã thực thi", "Luôn ném lỗi", "Luôn trả về list"],
      "answer": 0,
      "explanation": "Các phương thức trung gian (như map) của Stream là lazy – chúng chưa thực thi cho đến khi có một phương thức cuối (terminal operation) như forEach hoặc collect."
    },
    {
      "type": "mcq",
      "title": "Điều gì xảy ra khi gọi lệnh sau?",
      "code": "Optional.empty().get();",
      "options": ["NoSuchElementException", "null", "0", "EmptyOptionalError"],
      "answer": 0,
      "explanation": "Gọi get() trên một Optional rỗng sẽ ném ra NoSuchElementException."
    },
    {
      "type": "mcq",
      "title": "Khối try-with-resources có tự động đóng tài nguyên không?",
      "code": "Tự động đóng tài nguyên?",
      "options": ["Có, nếu AutoCloseable", "Không bao giờ", "Chỉ với File", "Chỉ với JDBC"],
      "answer": 0,
      "explanation": "Các tài nguyên thực hiện interface AutoCloseable sẽ được tự động đóng sau khi kết thúc khối try-with-resources."
    },
    {
      "type": "mcq",
      "title": "Annotation @Override sẽ làm gì khi phương thức không khớp chữ ký?",
      "code": "Báo lỗi nếu không khớp chữ ký?",
      "options": ["Đúng", "Sai", "Tuỳ JDK", "Chỉ dùng cho interface"],
      "answer": 0,
      "explanation": "@Override giúp trình biên dịch kiểm tra xem phương thức có thực sự override hay không. Nếu không khớp chữ ký, sẽ báo lỗi compile-time."
    },
    {
      "type": "mcq",
      "title": "IOException thuộc loại ngoại lệ nào?",
      "code": "IOException là?",
      "options": ["Checked", "Unchecked", "Error", "Không là exception"],
      "answer": 0,
      "explanation": "IOException là checked exception, buộc phải được bắt hoặc khai báo trong phương thức (throws)."
    },
    {
      "type": "mcq",
      "title": "Điểm khác biệt giữa start() và run() trong Thread là gì?",
      "code": "new Thread(r).start();",
      "options": ["start tạo thread mới", "run tạo thread mới", "Cả 2 giống nhau", "Cả 2 không tạo thread"],
      "answer": 0,
      "explanation": "start() khởi tạo một luồng mới và gọi run() bên trong nó. Nếu gọi trực tiếp run(), code chỉ chạy trong luồng hiện tại."
    },
    {
      "type": "mcq",
      "title": "Từ khóa synchronized dùng để làm gì?",
      "code": "Đảm bảo?",
      "options": ["Tương hỗ loại trừ (mutual exclusion)", "Tăng tốc I/O", "Bắt buộc GC", "Tối ưu JIT"],
      "answer": 0,
      "explanation": "Từ khóa synchronized đảm bảo chỉ một luồng được truy cập vùng code hoặc đối tượng tại một thời điểm, tránh xung đột dữ liệu."
    },
    {
      "type": "mcq",
      "title": "Điểm khác biệt chính giữa StringBuilder và StringBuffer là gì?",
      "code": "Khác biệt chính?",
      "options": ["Buffer là synchronized", "Builder là synchronized", "Không khác", "Buffer chậm nhất"],
      "answer": 0,
      "explanation": "StringBuffer là synchronized (an toàn luồng), còn StringBuilder không synchronized và nhanh hơn trong môi trường đơn luồng."
    },
    {
      "type": "mcq",
      "title": "Cấu trúc switch expression sau có hợp lệ trong Java 14+ không?",
      "code": "int x = switch(n){ case 1 -> 10; default -> 0; };",
      "options": ["Hợp lệ", "Không hợp lệ", "Chỉ từ Java 8", "Luôn ném lỗi"],
      "answer": 0,
      "explanation": "Switch expression với cú pháp '->' được giới thiệu từ Java 14, hợp lệ và có thể trả về giá trị."
    },
    {
      "type": "mcq",
      "title": "Record trong Java có đặc điểm gì?",
      "code": "public record P(int x,int y){}",
      "options": ["Bất biến (shallow)", "Mutable", "Không thể tạo", "Chỉ dành cho Android"],
      "answer": 0,
      "explanation": "Record trong Java tự động tạo constructor, equals, hashCode, toString và là bất biến (immutable) ở mức shallow."
    },
    {
      "type": "mcq",
      "title": "Từ khóa var trong Java dùng để làm gì?",
      "code": "var s = \"hi\";",
      "options": ["Suy luận kiểu tại compile-time", "Runtime", "Dynamic typing", "Bắt buộc với String"],
      "answer": 0,
      "explanation": "Từ khóa var cho phép trình biên dịch suy luận kiểu tại thời điểm biên dịch, nhưng vẫn là kiểu tĩnh (static typing)."
    },
    {
      "type": "mcq",
      "title": "String trong Java là immutable (bất biến).",
      "code": "",
      "options": ["Đúng", "Sai"],
      "answer": 0,
      "explanation": "String trong Java là immutable – mọi thao tác thay đổi đều tạo ra một đối tượng mới."
    },
    {
      "type": "mcq",
      "title": "Biến được khai báo với từ khóa var có thể thay đổi kiểu sau khi gán.",
      "code": "",
      "options": ["Đúng", "Sai"],
      "answer": 1,
      "explanation": "Kiểu của biến var được xác định tại compile-time và không thể thay đổi sau khi gán lần đầu."
    },
    {
      "type": "mcq",
      "title": "Một interface trong Java có thể chứa phương thức static.",
      "code": "",
      "options": ["Đúng", "Sai"],
      "answer": 0,
      "explanation": "Từ Java 8, interface có thể chứa phương thức static (và cả default)."
    },
    {
      "type": "mcq",
      "title": "Các biến final trong Java không thể được gán lại sau khi khởi tạo.",
      "code": "",
      "options": ["Đúng", "Sai"],
      "answer": 0,
      "explanation": "Biến final chỉ có thể được gán một lần. Sau khi gán giá trị, không thể thay đổi."
    },
    {
      "type": "mcq",
      "title": "Từ khóa this có thể được dùng trong phương thức static.",
      "code": "",
      "options": ["Đúng", "Sai"],
      "answer": 1,
      "explanation": "Phương thức static không thuộc về instance cụ thể, nên không thể sử dụng từ khóa this bên trong."
    }
  ]
}
